<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Video Call App</title>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js" defer></script>
	<script src="http://localhost:3000/socket.io/socket.io.js" defer></script>
	<style>
		.chat-message {
			max-width: 75%;
		}

		.chat-message.self {
			background-color: #1e40af;
			color: white;
		}

		.chat-message.other {
			background-color: #374151;
			color: white;
		}

		/* Dynamic grid for video participants */
		#videoGrid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 1rem;
			max-height: calc(100vh - 200px);
			overflow-y: auto;
		}

		/* Screen sharing layout */
		.screen-sharing-active #videoGrid {
			grid-template-columns: 1fr;
			grid-template-rows: auto auto;
		}

		.screen-sharing-active #localVideoContainer {
			grid-row: 1;
			height: 70vh;
		}

		.screen-sharing-active #localVideoContainer video {
			height: 100%;
			object-fit: contain;
			background-color: #000;
		}

		.screen-sharing-active #remoteVideosContainer {
			grid-row: 2;
			display: flex;
			flex-wrap: nowrap;
			overflow-x: auto;
			gap: 0.5rem;
		}

		.screen-sharing-active #remoteVideosContainer > div {
			min-width: 160px;
			max-width: 160px;
		}

		/* For smaller participant videos during screen sharing */
		.participant-video-container {
			position: relative;
			background-color: black;
			border-radius: 0.5rem;
			overflow: hidden;
		}

		.participant-name {
			position: absolute;
			bottom: 0.5rem;
			left: 0.5rem;
			color: white;
			font-size: 0.875rem;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
		}

		#publicChat,
		#privateChat {
			max-height: 460px;
			overflow-y: auto;
		}
	</style>
</head>

<body class="bg-gray-900 text-white min-h-screen flex flex-col">
	<!-- Header -->
	<header class="bg-gray-800 p-4 flex justify-between items-center">
		<h1 class="text-xl font-bold">Specto Meeting ID: <%= meetingId %>
		</h1>
		<div class="flex space-x-2">
			<button id="muteButton" class="bg-gray-600 px-3 py-2 rounded hover:bg-gray-700">Mute</button>
			<button id="videoButton" class="bg-gray-600 px-3 py-2 rounded hover:bg-gray-700">Video Off</button>
			<button id="shareScreen" class="bg-gray-600 px-3 py-2 rounded hover:bg-gray-700">Share Screen</button>
			<button id="reactions" class="bg-gray-600 px-3 py-2 rounded hover:bg-gray-700">Reactions</button>
			<button id="participantsList" class="bg-gray-600 px-3 py-2 rounded hover:bg-gray-700">Participants</button>
			<button id="endCall" class="bg-red-600 px-4 py-2 rounded hover:bg-red-700">Leave</button>
		</div>
	</header>

	<!-- Main Content -->
	<div class="flex-1 flex flex-row p-4 space-x-4">
		<!-- Video Section -->
		<div class="flex-1 bg-gray-800 rounded-lg p-4">
			<h2 class="text-lg font-semibold mb-2">Participants</h2>
			<div id="videoGrid" class="grid gap-4">
				<!-- Local video container -->
				<div id="localVideoContainer" class="participant-video-container">
					<video id="localVideo" autoplay playsinline muted class="w-full h-48 object-cover"></video>
					<p class="participant-name">You</p>
				</div>
				<!-- Remote videos container -->
				<div id="remoteVideosContainer" class="hidden"></div>
			</div>
		</div>

		<!-- Chat Section -->
		<div class="w-1/3 bg-gray-700 rounded-lg shadow-lg flex flex-col">
			<!-- Chat Tabs -->
			<div class="flex border-b border-gray-600">
				<button id="publicTab"
					class="flex-1 py-2 text-center bg-blue-700 text-white rounded-tl-lg hover:bg-blue-800">Public
					Chat</button>
				<button id="privateTab"
					class="flex-1 py-2 text-center bg-gray-600 text-white rounded-tr-lg hover:bg-gray-700">Private
					Chat</button>
			</div>

			<!-- Public Chat -->
			<div id="publicChat" class="flex-1 p-4 overflow-y-auto">
				<div id="publicMessages" class="space-y-2">
					<!-- Messages will be added here -->
				</div>
			</div>

			<!-- Private Chat -->
			<div id="privateChat" class="flex-1 p-4 overflow-y-auto hidden">
				<!-- User Selection -->
				<div class="sticky top-0 bg-gray-700 z-10 pb-2">
					<select id="privateUserSelect"
						class="w-full p-2 border rounded bg-gray-800 text-white border-gray-600">
						<option value="">Select a user</option>
					</select>
				</div>
				<div id="privateMessages" class="space-y-2">
					<!-- Private messages will be added here -->
				</div>
			</div>

			<!-- Chat Input -->
			<div class="p-4 border-t border-gray-600">
				<div class="flex space-x-2">
					<input id="chatInput" type="text"
						class="flex-1 p-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-800 text-white border-gray-600"
						placeholder="Type a message...">
					<button id="sendMessage"
						class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Send</button>
				</div>
			</div>
		</div>
	</div>

	<script id="app-data" type="application/json">
		<%- JSON.stringify({
			user,
			meetingSession,
			meetingId
		}) %>
	</script>

	<script defer>
		// Wait for DOM to be fully loaded
		document.addEventListener('DOMContentLoaded', () => {
			const rawData = document.getElementById('app-data').textContent;
			const appData = JSON.parse(rawData);

			const { user, meetingSession, meetingId } = appData;
			let localStream = null;

			console.log("the meeting in client is ", meetingId);

			// Current user (for demo purposes)
			const currentUser = user;

			// DOM Elements
			const publicTab = document.getElementById('publicTab');
			const privateTab = document.getElementById('privateTab');
			const publicChat = document.getElementById('publicChat');
			const privateChat = document.getElementById('privateChat');
			const publicMessages = document.getElementById('publicMessages');
			const privateMessages = document.getElementById('privateMessages');
			const privateUserSelect = document.getElementById('privateUserSelect');
			const chatInput = document.getElementById('chatInput');
			const sendMessage = document.getElementById('sendMessage');
			const endCall = document.getElementById('endCall');
			const muteButton = document.getElementById('muteButton');
			const videoButton = document.getElementById('videoButton');
			const shareScreen = document.getElementById('shareScreen');
			const reactions = document.getElementById('reactions');
			const participantsList = document.getElementById('participantsList');
			const videoGrid = document.getElementById('videoGrid');
			const localVideo = document.getElementById('localVideo');

			// Create socket for communication
			const socket = io('http://localhost:3000', {
				auth: {
					userId: user.id,
					meetingId: meetingId,
					meetingSessionId: meetingSession.id,
					fullname: user.fullname,
				}
			});

			// Create peer for media communication
			const peer = new Peer(undefined, {
				host: 'localhost',
				port: 3001,
				path: '/'
			});

			// Initialize local video stream
			function initLocalStream() {
				navigator.mediaDevices.getUserMedia({ video: true, audio: true })
					.then((stream) => {
						localStream = stream;
						
						// Set the local video stream
						if (localVideo) {
							localVideo.srcObject = stream;
							
							// Make sure the video plays
							localVideo.onloadedmetadata = (e) => {
								localVideo.play().catch(err => {
									console.error('Error playing local video:', err);
								});
							};
						}

						// Setup audio/video stream control
						setupStreamControls(stream);
					})
					.catch((err) => {
						console.error('Failed to get local stream:', err);
						// Show error message in video container
						const localVideoContainer = document.getElementById('localVideoContainer');
						if (localVideoContainer) {
							localVideoContainer.innerHTML = `
								<div class="flex items-center justify-center h-48 bg-gray-900">
									<p class="text-red-500">Camera/Mic access denied</p>
								</div>
								<p class="absolute bottom-2 left-2 text-white">You (No Video)</p>
							`;
						}
					});
			}

			// Setup stream controls (mute/unmute, video on/off)
			function setupStreamControls(stream) {
				// Mute button functionality
				muteButton.addEventListener('click', () => {
					const audioTracks = stream.getAudioTracks();
					if (audioTracks.length === 0) return;
					
					const isEnabled = audioTracks[0].enabled;
					audioTracks[0].enabled = !isEnabled;
					muteButton.textContent = isEnabled ? 'Unmute' : 'Mute';
				});

				// Video button functionality
				videoButton.addEventListener('click', () => {
					const videoTracks = stream.getVideoTracks();
					if (videoTracks.length === 0) return;
					
					const isEnabled = videoTracks[0].enabled;
					videoTracks[0].enabled = !isEnabled;
					videoButton.textContent = isEnabled ? 'Video On' : 'Video Off';
				});
			}

			// Initialize peer connection
			peer.on('open', function (id) {
				console.log('peer has id of: ', id);
				socket.emit('peerId', id);
			});

			// Add message to chat on user join
			socket.on('joinMessage', ({ message, recipient, sender, timestamp }) => {
				console.log('Message was sent to chat');
				addMessage(publicMessages, message, false, recipient, sender, timestamp);
			});

			// Add message to public chat on public message sent
			socket.on('publicMessage', ({ message, recipient, sender, timestamp }) => {
				const isSelf = sender.id === currentUser.id;
				addMessage(publicMessages, message, isSelf, recipient, sender, timestamp);
			});

			// Add message to private chat on private message sent
			socket.on('privateMessage', ({ message, recipient, sender, timestamp, realSenderId }) => {
				if (realSenderId) {
					if (realSenderId !== currentUser.id) {
						addMessage(privateMessages, message, false, sender, recipient, timestamp);
					} else {
						addMessage(privateMessages, message, true, recipient, sender, timestamp);
					}
				} else {
					const isSelf = sender.id === currentUser.id;
					addMessage(privateMessages, message, isSelf, recipient, sender, timestamp);
				}
			});

			// Notify server about user join
			socket.on('connect', () => {
				console.log('Connected to Socket.IO server with userId:', user.fullname);
				console.log('Current room is ', meetingId);
				// Join the room on connection
				setTimeout(() => {
					socket.emit('joinRoom');
				}, 500);
			});

			// Update video grid to add only those users' videos that are in the room
			socket.on('participantsUpdate', (participants) => {
				// Remove all remote participants 
				const remoteVideos = document.querySelectorAll('.participant-video-container:not(#localVideoContainer)');
				remoteVideos.forEach(el => el.remove());
				
				// Clear the participant select dropdown
				privateUserSelect.innerHTML = '<option value="">Select a user</option>';

				participants.forEach(participant => {
					// Add participants to private message dropdown
					if (participant.id !== currentUser.id) {
						const option = document.createElement('option');
						option.value = JSON.stringify(participant);
						option.textContent = participant.fullname;
						privateUserSelect.appendChild(option);

						// Add remote participant videos
						const div = document.createElement('div');
						div.classList.add('participant-video-container');
						div.innerHTML = `
							<video autoplay playsinline class="w-full h-48 object-cover"></video>
							<p class="participant-name">${participant.fullname}</p>
						`;
						
						// Append to the right container based on screen sharing status
						if (isScreenSharing) {
							document.getElementById('remoteVideosContainer').appendChild(div);
						} else {
							videoGrid.appendChild(div);
						}
					}
				});
			});

			// Handle private recipient change
			privateUserSelect.addEventListener('change', () => {
				privateMessages.innerHTML = '';

				const selectedValue = privateUserSelect.value;
				if (!selectedValue) return;

				const recipient = JSON.parse(selectedValue);

				console.log(`Private chat target changed to: ${recipient.fullname} (Socket ID: ${recipient.socketId})`);

				socket.emit('privateRecipientChanged', {
					recipient,
					sender: currentUser,
				});
			});

			// Send message
			sendMessage.addEventListener('click', sendChatMessage);
			chatInput.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') {
					sendChatMessage();
				}
			});

			function sendChatMessage() {
				const message = chatInput.value.trim();
				if (!message) return;

				const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

				if (!privateChat.classList.contains('hidden')) {
					const recipientValue = privateUserSelect.value;
					if (!recipientValue) {
						alert('Please select a user to send a private message.');
						return;
					}
					const recipient = JSON.parse(recipientValue);

					console.log('Private message is about to be sent to ', recipient.fullname);
					// Emit sending private message to server
					socket.emit('sendPrivateMessage', {
						message,
						recipient,
						sender: currentUser,
						timestamp,
					});
				} else {
					// Emit sending public message to server
					socket.emit('sendPublicMessage', {
						message,
						recipient: null,
						sender: currentUser,
						timestamp,
					});
				}

				chatInput.value = '';
			}

			// Add message to chat
			function addMessage(container, message, isSelf, recipient = null, sender, timestamp) {
				if (container === privateMessages) {
					// Only show messages for the selected private recipient
					const privateRecipientValue = privateUserSelect.value;
					if (!privateRecipientValue) return;
					
					const privateRecipient = JSON.parse(privateRecipientValue);
					if (
						privateRecipient.id !== recipient?.id &&
						privateRecipient.id !== sender?.id
					) return;
				}

				const div = document.createElement('div');
				div.classList.add('chat-message', 'p-2', 'rounded-lg', isSelf ? 'self' : 'other', isSelf ? 'ml-auto' : 'mr-auto');
				const senderText = isSelf ? 'You' : typeof sender !== 'string' ? sender.fullname : sender;
				div.innerHTML = `
					<div class="flex justify-between text-xs mb-1">
						<span>${senderText}${recipient ? (recipient.id !== currentUser.id ? ` to ${recipient.fullname}` : ' to You') : ''}</span>
						<span>${timestamp}</span>
					</div>
					<div>${message}</div>
				`;
				container.appendChild(div);
				container.scrollTop = container.scrollHeight;
			}

			// Tab switching
			publicTab.addEventListener('click', () => {
				publicTab.classList.add('bg-blue-700', 'text-white');
				publicTab.classList.remove('bg-gray-600');
				privateTab.classList.add('bg-gray-600');
				privateTab.classList.remove('bg-blue-700', 'text-white');
				publicChat.classList.remove('hidden');
				privateChat.classList.add('hidden');
			});

			privateTab.addEventListener('click', () => {
				privateTab.classList.add('bg-blue-700', 'text-white');
				privateTab.classList.remove('bg-gray-600');
				publicTab.classList.add('bg-gray-600');
				publicTab.classList.remove('bg-blue-700', 'text-white');
				privateChat.classList.remove('hidden');
				publicChat.classList.add('hidden');
			});

			// Screen sharing functionality
			let isScreenSharing = false;
			let screenStream = null;
			
			shareScreen.addEventListener('click', async () => {
				try {
					if (!isScreenSharing) {
						// Start screen sharing
						screenStream = await navigator.mediaDevices.getDisplayMedia({ 
							video: true,
							audio: true 
						});
						
						// Save the previous video for later
						const previousVideo = localVideo.srcObject;
						
						// Replace camera with screen share in local video
						if (localVideo) {
							localVideo.srcObject = screenStream;
						}
						
						// Apply screen sharing layout
						document.body.classList.add('screen-sharing-active');
						document.getElementById('remoteVideosContainer').classList.remove('hidden');
						
						// Move remote videos to the container
						const remoteVideos = document.querySelectorAll('#videoGrid > .participant-video-container:not(#localVideoContainer)');
						const remoteContainer = document.getElementById('remoteVideosContainer');
						remoteVideos.forEach(video => {
							remoteContainer.appendChild(video);
						});
						
						// Set the screen sharing flag
						isScreenSharing = true;
						shareScreen.textContent = 'Stop Sharing';
						
						// Handle when user stops screen sharing
						screenStream.getVideoTracks()[0].onended = () => {
							stopScreenSharing(previousVideo);
						};
					} else {
						// Stop screen sharing
						if (screenStream) {
							screenStream.getTracks().forEach(track => track.stop());
						}
						stopScreenSharing(localStream);
					}
				} catch (err) {
					console.error('Error sharing screen:', err);
					alert('Failed to start screen sharing.');
				}
			});
			
			function stopScreenSharing(originalStream) {
				// Restore original video stream
				if (localVideo && originalStream) {
					localVideo.srcObject = originalStream;
				}
				
				// Return to normal layout
				document.body.classList.remove('screen-sharing-active');
				
				// Move remote videos back to main grid
				const remoteVideos = document.querySelectorAll('#remoteVideosContainer > .participant-video-container');
				remoteVideos.forEach(video => {
					videoGrid.appendChild(video);
				});
				
				document.getElementById('remoteVideosContainer').classList.add('hidden');
				
				// Reset screen sharing state
				isScreenSharing = false;
				shareScreen.textContent = 'Share Screen';
				screenStream = null;
			}

			// Mock functionality for now
			reactions.addEventListener('click', () => {
				alert('Reactions menu opened.');
				// Add reactions logic here
			});

			participantsList.addEventListener('click', () => {
				alert('Participants list opened.');
				// Add participants list logic here
			});

			endCall.addEventListener('click', () => {
				if (confirm('Are you sure you want to leave this meeting?')) {
					// Stop all media tracks
					if (localStream) {
						localStream.getTracks().forEach(track => track.stop());
					}
					
					// Disconnect from socket and peer
					socket.disconnect();
					peer.destroy();
					
					// Redirect to home or meeting ended page
					window.location.href = '/';
				}
			});

			// Initialize local stream
			initLocalStream();
		});
	</script>
</body>

</html>